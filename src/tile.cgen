/*
Copyright Remco Bras and Michael de Lang 2007,2008
This file is part of RPGE.

RPGE is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.
RPGE is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

/*
tile.c: Implement the functions related to tiles and tilelayers. 
*/
#include "tile.h"

/*Declare convertor usage, so sed can find it and take care of the mess*/
convertors(tilelayer);

/*The sequence of current ready, loaded tilegrids (or tile_layers, whichever). The main idea here is to ensure that whatever links to the main grid is at any and all times 
  loaded. (Technically, the point is to A: be able to load the new grid immediately on transition, B: swap around tilegrids if necessary (a prereq of A, really) and C: make sure
  A carries over transitions).*/
sequence tile_layers;

/*We do need to know what world the user would like us to render*/
int maingrid_index;

tile 
make_tile(unsigned int tilesheet, SDL_Rect clipping, char blocking)
{
  tile t;
  t.tilesheetindex = tilesheet;
  t.sheetclippinginfo = clipping;
  t.blocking = blocking;
  t.occupant = NULL;
  return t;
}

/*Note: The caller should handle the memory allocated here.*/
tile**
init_tilegrid(unsigned int width,unsigned int height)
{
  tile** grid =  xmalloc(sizeof(tile*)*width);
  for(int i = 0; i < width; i++)
    {
      grid[i] = xmalloc(sizeof(tile)*height);
    }
  return grid;
}

tile**
tilegrid_replace_tile(tile** grid, unsigned int x, unsigned int y, tile replacement)
{
  grid[x][y]=replacement;
  return grid;
}

tile**
tilegrid_set_all_tiles(tile** grid, unsigned int gridwidth, unsigned int gridheight, tile replacement)
{
  for(int i = 0; i < gridwidth; i++)
    {
      for(int j = 0; j < gridheight; j++)
        {
          grid[i][j] = replacement;
        }
    }
  return grid;
}


tile** set_tile(tilelayer* grid, unsigned int x, unsigned int y, tile replacement)
{
  if(grid->tilegrid)
    {
      grid->tilegrid[x][y] = replacement;
      if(grid == MAIN_GRID)
	remake_tilegrid(grid);
      return grid->tilegrid;
    }
  else
    return NULL;
}

tile** set_all_tiles(tilelayer* grid,tile replacement)
{
  if(grid->tilegrid)
    {
      grid->tilegrid = tilegrid_set_all_tiles(grid->tilegrid,grid->width,grid->height,replacement);
      if(grid == MAIN_GRID)
	remake_tilegrid(grid);
      return grid->tilegrid;
    }
  else
    return NULL;
}  

/*Pre-render a tilegrid, avoiding duplication of blitting work when rendering frames*/
SDL_Surface*
remake_tilegrid(tilelayer* main_grid)
{
  SDL_Surface* display;
  if(!main_grid)
    return NULL;
  if(!main_grid->imagebuffer)
    {
      display = SDL_GetVideoSurface();
      main_grid->imagebuffer = SDL_CreateRGBSurface(SDL_HWSURFACE,main_grid->width*TILE_WIDTH,main_grid->height*TILE_HEIGHT,display->format->BitsPerPixel,display->format->Rmask,display->format->Gmask,display->format->Bmask,display->format->Amask);
    }
  else
    SDL_FillRect(main_grid->imagebuffer,NULL,SDL_MapRGB(main_grid->imagebuffer->format,0,0,0));
  render_tilegrid(main_grid->imagebuffer,main_grid->tilegrid,main_grid->width,main_grid->height);
  return main_grid->imagebuffer;
}

inline char 
occupied(int tilex, int tiley,int grid)
{
  return GRID_PTR(grid)->tilegrid[tilex][tiley].occupant != NULL;
}

inline void 
set_occupant(int tilex, int tiley,int grid, mob* new_occupant)
{
  GRID_PTR(grid)->tilegrid[tilex][tiley].occupant = new_occupant;
}

inline mob* 
get_occupant(int tilex, int tiley,int grid)
{
  return GRID_PTR(grid)->tilegrid[tilex][tiley].occupant;
}

inline void
reset_occupant(int tilex, int tiley,int grid)
{
  GRID_PTR(grid)->tilegrid[tilex][tiley].occupant = NULL;
}

int
add_tilegrid(tilelayer grid)
{
  object o;
  o.data = NULL;
  o.typeinfo = 0;
  int index_empty = sequence_position(tile_layers,o,NULL);
  if(index_empty == -1)
    return sequence_append(&tile_layers,make_tilelayer_obj(grid));
  else
    {
      tile_layers.data[index_empty] = make_tilelayer_obj(grid);
      return index_empty;
    }
}

void
remove_grid_at(int index)
{
  free_obj(tile_layers.data[index]);
  tile_layers.data[index].data = NULL;
  tile_layers.data[index].typeinfo = -1;
}
