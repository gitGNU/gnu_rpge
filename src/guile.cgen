/*
Copyright Remco Bras 2007,2008
This file is part of RPGE.

RPGE is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

RPGE is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#include "guile.h"

SCM global_userdata = SCM_EOL;
sequence argvs;
SDL_mutex* argv_lock;
convertors(thread_argv);

void
argvs_init()
{
  argvs = sequence_init();
  argv_lock = SDL_CreateMutex();
}

static SCM
scm_ncar (SCM list, int n)
{
  for (int i = 0; i < n; i++)
    {
      list = scm_car (list);
    }
  return list;
}

static SCM
scm_ncdr (SCM list, int n)
{
  for (int i = 0; i < n; i++)
    {
      list = scm_cdr (list);
    }
  return list;
}

static inline SCM
scm_nth (SCM list, int n)
{
  return scm_car (scm_ncdr (list, n - 1));
}

SCM
guile_create_mob (SCM x, SCM y, SCM grid, SCM string)
{
  char *filename = scm_to_locale_string (string);
  unsigned int xc = scm_to_uint (x), yc = scm_to_uint (y), gc = scm_to_uint(grid);
  return
    scm_from_int (push_mob_on_array
		  (create_mob_using_sprite (xc, yc, gc, filename)));
}

static inline tile
list_to_tile (SCM tilelist)
{
  tile t;
  SDL_Rect clip;
  t.tilesheetindex = push_image_on_stack(scm_to_locale_string(scm_cadr(tilelist)));
  clip.x = scm_to_int16 (scm_nth (tilelist,3));
  clip.y = scm_to_int16 (scm_nth (tilelist, 4));
  clip.w = scm_to_uint16 (scm_nth (tilelist, 5));
  clip.h = scm_to_uint16 (scm_nth (tilelist, 6));
  t.blocking = scm_to_char (scm_nth (tilelist, 7));
  t.sheetclippinginfo = clip;
  t.occupant = NULL;
  return t;
}

static inline SCM
tile_to_list (tile t)
{
  char* fname = get_image_name(t.tilesheetindex);
  SCM l = scm_list_n (scm_from_locale_symbol("tile"),
                      scm_from_locale_string (fname),
		      scm_from_int16 (t.sheetclippinginfo.x),
		      scm_from_int16 (t.sheetclippinginfo.y),
		      scm_from_uint16 (t.sheetclippinginfo.w),
		      scm_from_uint16 (t.sheetclippinginfo.h),
		      scm_from_char (t.blocking),
		      SCM_UNDEFINED);
  free(fname);
  return l;
}

/*
This seems deceptively similar to the above, but the major difference is that tile_to_list is meant for tiles already created, i.e. proper tiles with internalized images. Since it's rather tough (outside of smobs and the like) to keep track of image references in GUILE and it's more logical to not preload images for tiles a user just keeps around, we define the below function to deal with pseudotiles, i.e. tiles without a proper, internalized image. 
*/

static inline SCM
listify_pseudotile(char* filename, SDL_Rect clip, char blocking)
{
  return scm_list_n(scm_from_locale_symbol("tile"),
                    scm_from_locale_string(filename),
                    scm_from_int16(clip.x),
                    scm_from_int16(clip.y),
                    scm_from_uint16(clip.w),
                    scm_from_uint16(clip.h),
                    scm_from_char(blocking),
                    SCM_UNDEFINED);
}

SCM
guile_create_tile (SCM sprite, SCM partclip, SCM blocking)
{
  char *spritefilename = scm_to_locale_string (sprite);
  char block = scm_to_char (blocking);
  SDL_Rect r;
  r.x = scm_to_int16 (scm_car (partclip));
  r.y = scm_to_int16 (scm_cadr (partclip));
  r.w = scm_to_uint16 (scm_caddr (partclip));
  r.h = scm_to_uint16 (scm_cadddr (partclip));
  return
    listify_pseudotile(spritefilename,r,block);
}

SCM
guile_set_tile (SCM grid,SCM x, SCM y, SCM tile)
{
  set_tile (scm_to_int(grid),scm_to_int16 (x), scm_to_int16 (y), list_to_tile (tile));
  return scm_from_int (0);
}

SCM
guile_set_all_tiles (SCM grid,SCM tile)
{
  set_all_tiles (scm_to_int(grid),list_to_tile (tile));
  return scm_from_int (0);
}

SCM
guile_move_mob_all (SCM mobindex, SCM tilecountx, SCM tilecounty,
		    SCM frametotal)
{
  mob_move_all_by_index (scm_to_int(mobindex),
			 scm_to_int (tilecountx), scm_to_int (tilecounty),
			 scm_to_int (frametotal));
  return scm_from_int (0);
}

SCM
guile_set_mob_animation (SCM mobindex, SCM animation, SCM start,
			 SCM targetframe, SCM framesbetween, SCM loop)
{
  mob_set_animation_by_index (scm_to_int(mobindex),
			      scm_to_int (animation), scm_to_int (start),
			      scm_to_int (targetframe), scm_to_int (framesbetween),
			      scm_to_bool (loop));
  return scm_from_int (0);
}

SCM
guile_stop_mob_animation (SCM mobindex)
{
  mob_stop_animation_by_index (scm_to_int(mobindex));
  return scm_from_int (0);
}

SCM
guile_destroy_mob (SCM mobindex)
{
  remove_mob (scm_to_int (mobindex));
  return scm_from_int (0);
}

SCM
guile_make_tilegrid (SCM width, SCM height)
{
  tilelayer new_grid;
  memset(&new_grid,0,sizeof(tilelayer));
  new_grid.width = scm_to_int(width);
  new_grid.height = scm_to_int(height);
  new_grid.tilegrid=init_tilegrid(new_grid.width,new_grid.height);
  new_grid.imagecounts = sequence_init();
  return scm_from_int(add_tilegrid(new_grid));
}

SCM 
guile_remove_grid(SCM index)
{
  remove_grid_at(scm_to_int(index));
  return SCM_UNSPECIFIED;
}

SCM
guile_make_window (SCM width, SCM height, SCM x, SCM y, SCM filename,
		   SCM tilew, SCM tileh)
{
  return
    scm_from_int (windowstack_addwindow
		  (create_window
		   (scm_to_uint (width), scm_to_uint (height),
		    scm_to_uint (x), scm_to_uint (y),
		    scm_to_locale_string (filename), scm_to_uint (tilew),
		    scm_to_uint (tileh))));
}

SCM
guile_destroy_window (SCM index)
{
  windowstack_remove (scm_to_int (index));
  return scm_from_int (0);
}

SCM
guile_open_global_eventstack ()
{
  return scm_from_int (eventstack_open (&global_usereventstack));
}

SCM
guile_close_global_eventstack (SCM userindex)
{
  eventstack_close (&global_usereventstack, scm_to_int (userindex));
  return SCM_UNSPECIFIED;
}

SCM
guile_get_global_event (SCM userindex)
{
  event e = eventstack_get_first_of_user (&global_usereventstack,
					  scm_to_int (userindex));
  return scm_cons (e.type, e.data);
}


SCM
guile_set_mob_userdata (SCM index, SCM newdata)
{
  set_mob_userdata_by_index(scm_to_int(index),newdata);
  return SCM_UNSPECIFIED;
}

SCM
guile_get_mob_userdata (SCM index)
{
  return ((mob *) mobs.data[scm_to_int (index)].data)->userdata;
}

SCM
guile_get_global_userdata (void)
{
  return global_userdata;
}

SCM
guile_set_global_userdata (SCM newdata)
{
  scm_gc_unprotect_object (global_userdata);
  global_userdata = newdata;
  scm_gc_protect_object (global_userdata);
  return SCM_UNSPECIFIED;
}

/*
Technically, the following is a simple, though somewhat useful scheme to pass a single SCM to a script on boot. The whole point of this is to allow scripts that take 'arguments' to be used, in a rather warped way, somewhat like a procedure.
*/

thread_argv
make_threadargv (Uint32 threadid, SCM argv)
{
  thread_argv ta;
  ta.threadid = threadid;
  ta.argv = argv;
  return ta;
}

char
guile_argv_threadids_equalp (object argv, object threadid)
{
  return get_obj_Uint32 (threadid) == get_obj_thread_argv (argv).threadid;
}

void
guile_exec_script_with_argv (char *filename, SCM argv)
{
  Uint32 threadid = SDL_ThreadID ();
  int index = sequence_position (argvs, make_Uint32_obj (threadid),
				 guile_argv_threadids_equalp);
  SDL_mutexP(argv_lock);
  if (index != -1)
    argvs.data[index] =
      make_thread_argv_obj (make_threadargv (threadid, argv));
  else
    index =
      sequence_append (&argvs,
		       make_thread_argv_obj (make_threadargv
					     (threadid, argv)));
  SDL_mutexV(argv_lock);
  scm_c_primitive_load (filename);
  SDL_mutexP(argv_lock);
  sequence_remove_at (&argvs, index);
  SDL_mutexV(argv_lock);
}

SCM
guile_API_exec_script_with_argv (SCM filename, SCM argv)
{
  guile_exec_script_with_argv (scm_to_locale_string (filename), argv);
  return SCM_UNSPECIFIED;
}

SCM
guile_get_argv ()
{
  int index = sequence_position (argvs, make_Uint32_obj (SDL_ThreadID ()),
				 guile_argv_threadids_equalp);
  if (index != -1)
    return ((thread_argv *) argvs.data[index].data)->argv;
  else
    return SCM_EOL;
}

SCM
guile_open_font (SCM filename, SCM size)
{
  return
    scm_from_int (open_font
		  (scm_to_locale_string (filename), scm_to_int (size)));
}

SCM
guile_close_font (SCM index)
{
  close_font (scm_to_int (index));
  return SCM_UNSPECIFIED;
}

SCM
guile_make_text (SCM x, SCM y, SCM string, SCM font, SCM red, SCM green,
		 SCM blue)
{
  SDL_Color c;
  c.r = scm_to_uint8 (red);
  c.g = scm_to_uint8 (green);
  c.b = scm_to_uint8 (blue);
  return
    scm_from_int (add_text
		  (make_text
		   (scm_to_uint (x), scm_to_uint (y),
		    scm_to_locale_string (string), scm_to_int (font), c)));
}

SCM
guile_destroy_text (SCM textindex)
{
  remove_text (scm_to_int (textindex));
  return SCM_UNSPECIFIED;
}

SCM
guile_add_mob_movement (SCM mob, SCM xtile, SCM ytile, SCM frames)
{
  mob_add_movement_by_index(scm_to_int(mob),scm_to_int(xtile),scm_to_int(ytile),scm_to_int(frames));
  return SCM_UNSPECIFIED;
}

SCM
guile_get_camera_x()
{
  return scm_from_int(global_camera.tilex);
}

SCM
guile_get_camera_y()
{
  return scm_from_int(global_camera.tiley);
}

SCM 
guile_set_camera_x(SCM newvalue)
{
  global_camera.tilex = scm_to_int(newvalue);
  return SCM_UNSPECIFIED;
}

SCM
guile_set_camera_y(SCM newvalue)
{
  global_camera.tiley = scm_to_int(newvalue);
  return SCM_UNSPECIFIED;
}

SCM 
guile_open_mob_eventstack(SCM mobindex)
{
  return scm_from_uint(eventstack_open(&(((mob*)mobs.data[scm_to_int(mobindex)].data)->events)));
}

SCM
guile_get_mob_event(SCM mobindex, SCM luser)
{
  event e = eventstack_get_first_of_user(&((mob*)mobs.data[scm_to_int(mobindex)].data)->events,scm_to_uint(luser));
  return scm_cons(e.type,e.data);
}

SCM
guile_close_mob_eventstack(SCM mobindex, SCM luser)
{
  eventstack_close(&(((mob*)mobs.data[scm_to_int(mobindex)].data)->events),scm_to_uint(luser));
  return SCM_UNSPECIFIED;
}

SCM 
scm_c_safe_load(char* filename)
{
  SCM load_mutex = scm_variable_ref(scm_c_lookup("load-mutex"));
  scm_lock_mutex(load_mutex);
  scm_c_primitive_load(filename);
  scm_unlock_mutex(load_mutex);
  return SCM_UNSPECIFIED;
}

SCM
guile_safe_load(SCM filename)
{
  char* path = get_path(scheme_paths,scm_to_locale_string(filename));
  if(path)
    {
      scm_c_safe_load(path);
      free(path);
    }
  else
    fprintf(stderr,"RPGE: Cannot find Scheme source file in . or Scheme search paths: %s\n",scm_to_locale_string(filename));
  return SCM_UNSPECIFIED;
}

SCM
guile_set_mob_frame(SCM index, SCM animation, SCM framenum)
{
  set_mob_frame_by_index(scm_to_int(index),scm_to_uint(animation),scm_to_uint(framenum));
  return SCM_UNSPECIFIED;
}

SCM
guile_get_window_coordinates(SCM index)
{
  window w = get_obj_window(windows.data[scm_to_int(index)]);
  return scm_cons(scm_from_int(w.x),scm_from_int(w.y));
}

SCM
guile_get_window_dimensions(SCM index)
{
  window w = get_obj_window(windows.data[scm_to_int(index)]);
  return scm_cons(scm_from_int(w.width),scm_from_int(w.height));
}

SCM
guile_move_window(SCM index, SCM point)
{
  move_window(scm_to_int(index),scm_to_uint(scm_car(point)),scm_to_uint(scm_cdr(point)));
  return SCM_UNSPECIFIED;
}

SCM
guile_resize_window(SCM index, SCM dimensions)
{
  resize_window(scm_to_int(index),scm_to_uint(scm_car(dimensions)),scm_to_uint(scm_cdr(dimensions)));
  return SCM_UNSPECIFIED;
}

SCM
guile_move_text(SCM index, SCM point)
{
  move_text(scm_to_int(index),scm_to_uint(scm_car(point)),scm_to_uint(scm_cdr(point)));  
  return SCM_UNSPECIFIED;
}

SCM
guile_get_text_coordinates(SCM index)
{
  int ind = scm_to_int(index);
  text* t = (text*)texts.data[ind].data;
  return scm_cons(scm_from_uint(t->x),scm_from_uint(t->y));
}

SCM
obj_to_scm(object o)
{
  /*To do: implement dispatching*/
  if(o.typeinfo == TYPE_STRING)
    return scm_from_locale_string(*((char**)o.data));
  return SCM_EOL;
}

SCM
guile_sequence_to_list(sequence s)
{
  SCM last = scm_cons(obj_to_scm(s.data[0]),SCM_EOL),current,first = last;
  for(int i = 1; i < s.objcount; i++)
    {
      current = scm_cons(obj_to_scm(s.data[i]),SCM_EOL);
      scm_set_cdr_x(last,current);
      last = current;
    }
  return first;
}

SCM
guile_get_text_line_list(SCM index)
{
  return guile_sequence_to_list(((text*)texts.data[scm_to_int(index)].data)->buffers);
}

SCM
guile_set_main_grid(SCM g)
{
  set_maingrid_index(scm_to_int(g));  
  return SCM_UNSPECIFIED;
}

SCM
guile_get_main_grid()
{
  return scm_from_int(maingrid_index);
}

SCM
guile_run_repl()
{
  /*Since the repl_signal mutex is locked by the main loop, use an event to signal it needs to be released*/
  SDL_Event* e = malloc(sizeof(SDL_Event));
  e->type = SDL_USEREVENT;
  e->user.code = RELEASE_REPL_MUTEX;
  SDL_PushEvent(e);
  return SCM_UNSPECIFIED;
}

SCM
guile_stop_repl()
{
  SDL_Event* e = malloc(sizeof(SDL_Event));
  e->type = SDL_USEREVENT;
  e->user.code = ACQUIRE_REPL_MUTEX;
  SDL_PushEvent(e);
  return SCM_UNSPECIFIED;
}
